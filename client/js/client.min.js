'use strict';const listeners = new Set();

class Preferences {

	static getAll() {
		let preferences = localStorage.getItem("preferences");
		if (!preferences) {
			preferences = {};
		} else {
			preferences = JSON.parse(preferences);
		}
		return preferences;
	}

	static get(key) {
		return Preferences.getAll()[key];
	}

	static set(key, val) {
		let preferences = Preferences.getAll();
		preferences[key] = val;
		localStorage.setItem("preferences", JSON.stringify(preferences));

		for (let listener of listeners) {
			listener(key, val);
		}

		return preferences[key];
	}

	static subscribe(listener) {
		listeners.add(listener);
	}

}function randomUsername() {
	return "User" + Math.floor(Math.random() * 1000);
}

class Preference extends HTMLElement {

	static get observedAttributes() {
		return ['placeholder', 'key', 'type', 'checked'];
	}

	constructor() {
		super();

		this.key = null;

		this.input = document.createElement("input");
		this.input.onblur = () => this.onChange(this.input.value);
		this.input.onchange = () => this.onChange(this.input.value);

		Preferences.subscribe((key, value) => {
			if (this.key == key) {
				if (this.type == "checkbox") {
					this.input.checked = value;
				}
				if (value && value.length > 2) {
					this.input.value = value;
				}
			}
		});
	}

	attributeChangedCallback(name, oldValue, newValue) {
		this[name] = newValue;
	}

	set placeholder(val) { this.input.placeholder = val; }
	get placeholder() { return this.input.placeholder; }

	set type(val) { this.input.type = val; }
	get type() { return this.input.type; }

	set checked(val) { this.input.checked = val; }
	get checked() { return this.input.checked; }

	onChange(value) {
		if (this.type == "checkbox") {
			Preferences.set(this.key, this.input.checked);
		}
		if (value && value.length > 2) {
			Preferences.set(this.key, value);
		}
	}

	connectedCallback() {
		this.innerHTML = "";
		this.appendChild(this.input);

		let value = Preferences.get(this.key);
		if (!value && this.key == "username") {
			// gen random username
			value = Preferences.set(this.key, randomUsername());
		}
		if (value) {
			this.input.value = value;
		}
	}
}

class PreferenceSwitch extends Preference {
	constructor() {
		super();
		this.type = "checkbox";
		this.input.checked = false;
		this.input.onblur = () => { };
		this.input.onchange = () => this.onChange(this.input.checked);
	}

	connectedCallback() {
		super.connectedCallback();
		const handle = document.createElement("span");
		handle.className = "handle";
		this.appendChild(handle);

		this.onChange();
	}
}

customElements.define("w2-preference", Preference);
customElements.define("w2-preference-switch", PreferenceSwitch);class Itemlist extends HTMLElement {

	constructor() {
		super();

		this.list = [];
	}

	connectedCallback() {
		this.render();
	}

	display(arr) {
		this.list = arr;
		this.render();
	}

	render() {
		this.innerHTML = "";
		for(let item of this.list) {
			const ele = document.createElement("div");
			ele.className = "item";
			ele.innerHTML = item;
			this.appendChild(ele);
		}
	}
}

customElements.define("w2-itemlist", Itemlist);const services = new Map();

class Service {

    static valueOf() {
        return this.serviceName;
    }

    static registerService(service) {
        services.set(service.serviceName, service);
    }

    static getService(name) {
        return services.get(name) || Service;
    }

    static filterServiceId(url) {
        return url;
    }

    static parseServiceUrl(url) {
        const ids = [];
        let currentService = null;

        for (let service of services) {
            const id = service[1].filterServiceId(url);
            if (id) {
                ids.push(id);
                currentService = service[1];
            }
        }

        if (ids.length > 0) {
            return {
                id: ids[0],
                service: currentService.serviceName,
                link: url,
            }
        }
        return null;
    }

    // interface

    static get serviceName() {
        return "unknown";
    }

    static async getThumbnailURL(id) {
        return `/res/thumb.png`;
    }

    static async getVideoMetaData(id) {
        return null;
    }

    static getVideoURL(id) {
        console.warn("can't open, unknown service"); r;
        return null;
    }

}class VideoList extends HTMLElement {

	get Item() {
		return VideoListItem;
	}

	constructor() {
		super();
		this.list = [];
	}

	connectedCallback() {
		this.innerHTML = "";
		this.render();
	}

	render() {
		this.innerHTML = "";

		for (let i = 0; i < this.list.length; i++) {
			const vid = this.list[i];
			const item = new this.Item({
				id: vid.id,
				service: vid.service,
			});
			item.onPlay = () => {
				this.playVideo(i, vid);
			};
			item.onDelete = () => {
				this.removeVideo(i, vid);
			};
			this.appendChild(item);
		}
	}

	removeVideo(index, vid) { /* hook */ }

	playVideo(index, vid) { /* hook */ }
}

class VideoListItem extends HTMLElement {

	constructor({ id, service }) {
		super();

		this.vidid = id;
		this.service = service;
	}

	set vidid(val) {
		this.setAttribute("vidid", val);
	}

	get vidid() {
		return this.getAttribute("vidid");
	}

	connectedCallback() {
		this.innerHTML = "";

		const overlay = document.createElement("div");
		overlay.className = "controls";

		const pbtn = document.createElement("button");
		pbtn.innerHTML = "play_arrow";
		pbtn.title = "Play this video";
		pbtn.className = "playbtn material-icons";
		pbtn.onclick = this.onPlay.bind(this);

		const dbtn = document.createElement("button");
		dbtn.innerHTML = "remove_circle";
		dbtn.title = "Remove this video";
		dbtn.className = "delbtn material-icons";
		dbtn.onclick = this.onDelete.bind(this);

		const openbtn = document.createElement("button");
		openbtn.innerHTML = "open_in_new";
		openbtn.title = "Open video on YouTube";
		openbtn.className = "openbtn material-icons";
		openbtn.onclick = this.onOpen.bind(this);

		overlay.appendChild(openbtn);
		overlay.appendChild(pbtn);
		overlay.appendChild(dbtn);

		this.appendChild(overlay);

		const thumbnail = new Image();

		const service = Service.getService(this.service);

		service.getThumbnailURL(this.vidid).then(url => {
			thumbnail.src = url;
		});

		if (this.parentNode.hasAttribute('show-statistics')) {
			service.getVideoMetaData(this.vidid).then(stats => {
				this.statistics = stats;

				const statsEle = document.createElement('div');
				statsEle.className = "statistics";

				const opts = {
					style: "decimal",
					minimumIntegerDigits: 3,
					minimumSignificantDigits: 3,
				};

				const rating = new Intl.NumberFormat('en-EN', opts).format(this.statistics.likeCount - this.statistics.dislikeCount);
				const views = new Intl.NumberFormat('en-EN', opts).format(this.statistics.viewCount);

				statsEle.innerHTML = `
					<a><i class="material-icons" style="font-size: 12px;">thumb_up_alt</i> ${rating}</a>
					<a><i class="material-icons" style="font-size: 12px;">remove_red_eye</i> ${views}</a>
				`;

				this.appendChild(statsEle);
			});
		}

		this.append(thumbnail);
	}

	onOpen() {
		const a = document.createElement("a");

		const service = Service.getService(this.service);
		const videoURL = service.getVideoURL(this.vidid);

		a.href = videoURL;
		a.target = "blank";
		a.click();
	}

}

customElements.define("w2-videolist", VideoList);
customElements.define("w2-videolist-item", VideoListItem);class Notification {

	static get TEXT() { return 0; }

	constructor({
		text = "",
		time = 2000,
		type = Notification.TEXT
	} = {}) {
		this.text = text;
		this.time = time;
		this.type = type;
	}

	display(container) {
		const text = this.text;
		const time = this.time;

		if (container) {
			const note = document.createElement("w2-notification");

			switch (this.type) {

				case Notification.TEXT:
					note.innerText = text;
					break;
			}

			function close() {
				note.style.setProperty("animation", "fade-out .25s ease");
				setTimeout(() => { note.remove(); }, 200);
			}

			const timer = setTimeout(() => close(), time);

			note.onclick = () => {
				clearTimeout(timer);
				onclick && onclick(note);
				close();
			};

			container.appendChild(note);

			return note;
		}
	}

}function displayNotification(text, time) {
	if (!Preferences.get('hide_notifictions')) {
		const noti = new Notification({ type: Notification.TEXT, text, time });
		noti.display(document.querySelector("w2-notifications"));
	}
}

function displayReloadPrompt() {
	const ele = document.createElement('div');
	ele.className = "reload-prompt";
	ele.innerHTML = `
		<style>
			.reload-prompt {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				z-index: 10000;
				padding: 20px;
				box-sizing: border-box;
				border-radius: 4px;
				display: flex;
				justify-content: center;
				align-items: center;
				flex-direction: column;
				background: rgba(0, 0, 0, 0.75);
				padding-bottom: 100px;
			}
		</style>
		<p>
			<h2>Something went wrong.</h2>
			<a>Please reload the page.</a>
		</p>
		<button onclick="location.reload()">Reload</button>
	`;
	document.body.appendChild(ele);
	return ele;
}

let reconnecting;

class WatchClient {

	get username() { return Preferences.get("username"); }

	isHost() {
		return this.id === this.host;
	}

	constructor() {
		this.client = new HotelClient();

		this.client.connect();

		this.updaterate = 500;

		this.room = null;
	}

	init() {
		const player = document.querySelector("w2-player");

		setInterval(() => {
			if (player.loaded) {
				this.client.emit('player.state', {
					service: player.service,
					time: player.getCurrentTime(),
					id: player.currentVideoId,
					timestamp: Date.now(),
					state: player.state
				});

				if (queue.list.length > 1 &&
					Preferences.get('autoplay') &&
					Math.floor(player.getCurrentTime()) >= Math.floor(player.getDuration())) {
					const queue = document.querySelector("w2-videolist#queue");
					this.loadVideo({
						index: 1,
						id: queue.list[1].id,
					});
				}
			}
		}, this.updaterate);

		this.events = {

			'disconnect': () => {
				displayNotification("ERROR: Disconnected", 2000);

				if (!reconnecting) {
					reconnecting = setInterval(() => {
						if (!this.client.connectd) {
							this.client.connect();
						} else {
							this.connect(location.pathname);
							clearInterval(reconnecting);
							reconnecting = null;
						}
					}, 1000);
				} else {
					displayReloadPrompt();
				}
			},

			'join': msg => {
				this.id = msg.id;
			},

			'message': msg => {
				displayNotification(msg.message, 2500);
			},

			'room.state': msg => {
				this.host = msg.host;

				if (msg.hostonly) {
					document.querySelector('main').setAttribute('host-only', '');
				} else {
					document.querySelector('main').removeAttribute('host-only');
				}

				Preferences.set('hostonly', msg.hostonly);

				if (this.isHost()) {
					document.querySelector('main').setAttribute('host', '');
				} else {
					document.querySelector('main').removeAttribute('host');
				}
			},

			'user.list': msg => {
				const userlist = document.querySelector("w2-itemlist.userlist");
				let users = msg.map(user => {
					const a = document.createElement("a");
					a.innerText = user.username;
					const tag = user.host ? "host" : "";
					return `${a.innerText} <span class="usertag ${tag}" title="${tag}"></span>`;
				});
				userlist.display(users);
			},

			'queue.list': msg => {
				const queue = document.querySelector("w2-videolist#queue");
				queue.list = msg;
				queue.render();
			},

			'history.list': msg => {
				const history = document.querySelector("w2-videolist#history");
				history.list = msg.reverse();
				history.render();
			},

			'player.state': data => {
				player.loadVideo({
					state: data.state,
					service: data.service,
					id: data.id,
					startSeconds: data.time + (data.timestamp ? 1 + ((Date.now() - data.timestamp) / 1000) : 0) + ((this.updaterate / 2) / 1000),
				}, data.state);
			},

			'play.video': () => {
				player.play();
			},

			'pause.video': () => {
				player.pause();
			},

			'seek.video': msg => {
				const currentTime = player.getCurrentTime();
				const diff = msg.time - currentTime;

				if (diff > 0.5 || diff < -0.5) {
					player.seekTo(msg.time);
					displayNotification(`Seeked ${Math.floor(diff)} seconds`, 2000);
				}
			},
		};

		this.initListeners(this.events);
	}

	initListeners(events) {
		for (let event in events) {
			this.client.on(event, msg => {
				events[event](msg);
			});
		}
	}

	emit(event, msg) {
		this.client.emit(event, msg);
	}

	connect(roomId) {
		const socket = this.client;

		this.room = roomId;

		socket.emit('join', {
			roomId: roomId,
			username: this.username
		});

		displayNotification("Connected", 2500);
	}

	addVideoToQueue(service, id) {
		this.client.emit('queue.add', { service, id });

		const queue = document.querySelector("w2-videolist#queue");
		return queue.list;
	}

	removeVideoFromQueue(video) {
		this.client.emit('queue.remove', {
			index: video.index,
			id: video.id
		});
	}

	loadVideo(video) {
		this.client.emit('queue.play', {
			index: video.index,
			id: video.id,
		});
	}
}

class HotelClient {

	emit(type, data) {
		this.send({ type, data });
	}

	on(type, callback) {
		if (!this.listeners.has(type)) {
			this.listeners.set(type, []);
		}
		const arr = this.listeners.get(type);
		arr.push(callback);
	}

	constructor() {
		this.connectd = false;
		this.listeners = new Map();
		this.pingRate = 5000;
		this.pingTimer = null;
	}

	send(data) {
		if (this.connectd) {
			this.socket.send(JSON.stringify(data));
		}
	}

	sendBinary(data) {
		this.socket.send(data);
	}

	onMessage(e) {
		// console.log('[WebSocket] Message recieved', e);

		const listeners = this.listeners.get(e.type);
		if (listeners) {
			for (let listener of listeners) {
				listener(e.data);
			}
		}
	}

	ping() {
		this.send({ type: 'ping' });

		clearTimeout(this.pingTimer);
		this.pingTimer = setTimeout(this.ping.bind(this), this.pingRate);
	}

	onConnect(e) {
		console.log('[WebSocket] connected to', this.socket.url);

		this.ping();
	}

	onError(e) {
		console.log('[WebSocket] error on socket', e);

		displayReloadPrompt();
	}

	onClose(e) {
		console.log('[WebSocket] socket closed', e);

		const listeners = this.listeners.get('disconnect');
		if (listeners) {
			for (let listener of listeners) {
				listener(e.data);
			}
		}
	}

	connect() {
		return new Promise((resolve, reject) => {
			if (this.connectd) reject('already connected');

			this.protocol = location.protocol == "https:" ? "wss:" : "ws:";

			this.socket = new WebSocket(`${this.protocol}//${location.host}/`);

			this.socket.onmessage = e => {
				if (e.data instanceof Blob) {
					this.onMessage(e.data);
				} else {
					try {
						const json = JSON.parse(e.data);
						this.onMessage(json);
					} catch (err) {
						console.error('recieved unhandled response', err);
					}
				}
			};

			this.socket.onopen = e => {
				this.connectd = true;
				resolve(this.socket);
				this.onConnect(e);
			};

			this.socket.onerror = e => {
				this.connectd = false;
				reject('error connecting to socket');
				this.onError(e);
			};
			this.socket.onclose = e => {
				this.connectd = false;
				this.onClose(e);
			};
		})
	}

}class PlayerInterface {

    get service() {
        return "player_service";
    }

    constructor(containerId) {
        this.containerId = containerId;
        this.player = null;
    }

    onStateChange(state) {
        // state change hook
    }

    onReady() {
        // rady hook
    }

    setup() {
        // create player api instance etc.
    }

    play() {
        // play video
    }

    pause() {
        // pause video
    }

    seekTo(time) {
        // seek video
    }

    getCurrentTime() {
        // return video timestamp
    }

    getDuration() {
        // return video length
    }

    loadVideo(video) {
        // load video by id
    }

    unloadVideo() {
        // on unload video or video change
    }

}

PlayerInterface.EMPTY = 0;
PlayerInterface.PLAYING = 1;
PlayerInterface.PAUSED = 2;
PlayerInterface.SEEKING = 3;class Player extends HTMLElement {

	static get template() {
		return `
			<div class="player" id="placeholder">
				<h3>
					1. Copy Video URL
				</h3>
				<h3>
					2. Press the "Paste" button on the top left or press Ctrl+V, to insert the video.
				</h3>
				<h3>
					3. Watch the video in sync with your friends.
				</h3>

				<p>
					<a style="color: grey; font-size: 14px;">
						Only YouTube and Twitch VODs (not clips) can be played back synchronously
					</a>
				</p>
			</div>
		`;
	}

	get player() {
		if (this.video.service) {
			return this.players[this.video.service];
		}
	}

	get currentVideoId() {
		return this.video.id;
	}

	constructor() {
		super();

		this.loaded = false;
		this.state = 0;

		this.players = {};

		this.video = {
			id: null,
		};
	}

	registerPlayerInterface(interfaceInstance) {
		this.players[interfaceInstance.service] = interfaceInstance;

		const container = document.createElement('div');
		container.className = 'player';
		container.id = interfaceInstance.containerId;
		this.insertBefore(container, this.querySelector('#placeholder'));

		interfaceInstance.setup();

		interfaceInstance.onStateChange = state => {
			this.onStateChange(state);
		};

		interfaceInstance.onReady = () => {
			this.onReady();
		};
	}

	connectedCallback() {
		this.innerHTML = this.constructor.template;
	}

	loadVideo({ service, id, startSeconds }, state) {
		if (!service || !id) return;

		if (this.loaded) {
			this.pause();
		}
		this.loaded = false;

		const currentPlayer = this.players[this.video.service];

		if (currentPlayer) {
			currentPlayer.unloadVideo();
			document.querySelector('#' + currentPlayer.containerId).removeAttribute('style');
		}

		const playerInterface = this.players[service];
		playerInterface.loadVideo({ service, id, startSeconds }, state);

		document.querySelector('#' + playerInterface.containerId).style.zIndex = 1000;

		this.video.id = id;
		this.video.service = service;

		if (state == PlayerInterface.PAUSED) {
			this.pause(true);
		} else if (state == PlayerInterface.PLAYING) {
			this.play(true);
		}
	}

	play(force) {
		if (this.state !== PlayerInterface.PLAYING || force) {
			this.player.play();
		}
	}

	pause(force) {
		if (this.state !== PlayerInterface.PAUSED || force) {
			this.player.pause();
		}
	}

	seekTo(t) {
		this.player.seekTo(t);
	}

	getCurrentTime() {
		return this.player.getCurrentTime();
	}

	getDuration() {
		return this.player.getDuration();
	}

	setupPlayer() {

		let lastPlayerTime = 0;

		const tick = () => {
			requestAnimationFrame(tick);

			if (!this.player) return;

			const currentTime = this.getCurrentTime();
			if (this.loaded) {
				if (lastPlayerTime > 1) {
					const diff = currentTime - lastPlayerTime;
					if (Math.abs(diff) > 1) {
						this.dispatchEvent(new CustomEvent("seek", {
							detail: { time: currentTime }
						}));
					}
				}
				lastPlayerTime = currentTime;
			}
		};
		tick();
	}

	onReady() {
		this.dispatchEvent(new CustomEvent("ready"));
	}

	onStateChange(state) {
		this.state = state;

		if (this.loaded) {
			switch (state) {
				case PlayerInterface.PLAYING:
					this.dispatchEvent(new CustomEvent("play"));
					break;
				case PlayerInterface.PAUSED:
					this.dispatchEvent(new CustomEvent("pause"));
					break;
			}

			this.dispatchEvent(new CustomEvent("statechange", {
				detail: { state: state }
			}));
		}

		if (state == PlayerInterface.PLAYING) {
			this.loaded = true;
		}
	}
}

customElements.define("w2-player", Player);class YouTube extends Service {

    static get serviceName() {
        return "youtube.com";
    }

    static filterServiceId(url) {

        try {
            const parsedURL = new URL(url);

            if (parsedURL.origin.match("youtu.be")) {
                return parsedURL.pathname.substring(1);
            }

            if (parsedURL.origin.match("www.youtube.com")) {
                const split = parsedURL.search.substring(1).split("&");
                for (let part of split) {
                    if (part[0] == "v") {
                        return part.split("=")[1];
                    }
                }
            }
        } catch (err) {
            return null;
        }

        return null;
    }

    static async getThumbnailURL(id) {
        return `https://i1.ytimg.com/vi/${id}/hqdefault.jpg`;
    }

    static async getVideoMetaData(id) {
        const key = 'AIzaSyC4wOJP8qY0v2D54DPuOsXimxuDEbbuU3Q';
        const url = `https://www.googleapis.com/youtube/v3/videos?part=statistics&id=${id}&key=${key}`;
        return fetch(url).then(async res => {
            const json = await res.json();

            if (json.items.length > 0) {
                const item = json.items[0];

                return {
                    viewCount: item.statistics.viewCount,
                    likeCount: item.statistics.likeCount,
                    dislikeCount: item.statistics.dislikeCount,
                };
            }
        })
    }

    static getVideoURL(id) {
        return "https://www.youtube.com/watch?v=" + id;
    }

}class Twitch$1 extends Service {

    static get serviceName() {
        return "twitch.tv";
    }

    static filterServiceId(url) {
        const match = url.match(/(?:twitch.tv\/videos\/)([^\s&]+)/);
        return match ? match[1] : null;
    }

    static async getThumbnailURL(id) {
        const clientId = "mdn23u65h8g1mxrg0kr9yaw51vivmj";
        const url = `https://api.twitch.tv/kraken/videos/${id}?client_id=${clientId}`;
        return fetch(url).then(res => res.json().then(json => {
            return json.thumbnails[0].url;
        }));
    }

    static getVideoURL(id) {
        return "https://www.twitch.tv/videos/" + id;
    }

}class IFrames extends Service {

    static get serviceName() {
        return "iframe";
    }

    static filterServiceId(url) {

        if (url.match("clips.twitch.tv")) {
            const split = url.split("/");
            return "twitchclip:" + split[split.length - 1];
        }

        if (url.match(/(https:\/\/www\.twitch\.tv\/.*\/clip\/([^\s&]+))/g)) {
            const split = url.split("/");
            return "twitchchannelclip:" + split[split.length - 1].split("?")[0];
        }

        if (url.match(/\.twitch.tv\/.+/g)) {
            const split = url.split("/");
            return "twitch:" + split[split.length - 1];
        }
    }

    static getVideoURL(id) {
        const ID = id.split(":");

        switch (ID[0]) {
            case "twitchclip": return `https://clips.twitch.tv/embed?clip=${ID[1]}`;
            case "twitchchannelclip": return `https://clips.twitch.tv/embed?clip=${ID[1]}`;
            case "twitch": return `https://player.twitch.tv/?channel=${ID[1]}`;
        }
    }

}class YouTubePlayer extends PlayerInterface {

    get service() {
        return "youtube.com";
    }

    setup() {
        this.player = new YT.Player(this.containerId, {
            events: {
                'onStateChange': state => {
                    this.onStateChange(state.data);
                },
                'onReady': () => {
                    this.onReady();
                }
            }
        });
    }

    play() {
        this.player.playVideo();
    }

    pause() {
        this.player.pauseVideo();
    }

    seekTo(time) {
        return this.player.seekTo(time);
    }

    getCurrentTime() {
        return this.player.getCurrentTime();
    }

    getDuration() {
        return this.player.getDuration();
    }

    loadVideo({ service, id, startSeconds }, state) {
        this.player.loadVideoById({
            videoId: id,
            startSeconds: startSeconds,
        });
    }

}class TwitchPlayer extends PlayerInterface {

    get service() {
        return "twitch.tv";
    }

    setup() {
        this.player = new Twitch.Player(this.containerId);
        this.player.addEventListener(Twitch.Player.PAUSE, () => {
            this.onStateChange(PlayerInterface.PAUSED);
        });
        this.player.addEventListener(Twitch.Player.PLAYING, () => {
            this.onStateChange(PlayerInterface.PLAYING);
        });
    }

    play() {
        this.player.play();
    }

    pause() {
        this.player.pause();
    }

    seekTo(time) {
        return this.player.seek(time);
    }

    getCurrentTime() {
        return this.player.getCurrentTime();
    }

    getDuration() {
        return this.player.getDuration();
    }

    loadVideo({ service, id, startSeconds }, state) {
        this.player.setVideo("v" + id, startSeconds);
    }

}class IFramePlayer extends PlayerInterface {

    get service() {
        return "iframe";
    }

    loadVideo({ service, id, startSeconds }, state) {
        const playerService = Service.getService(service);

        if (!playerService) return;

        document.querySelector('#' + this.containerId).innerHTML = `
            <iframe
                src="${playerService.getVideoURL(id)}"
                frameborder="none"
            </iframe>
        `;
    }

    unloadVideo() {
        document.querySelector('#' + this.containerId).innerHTML = "";
    }

}class Room {

	static get id() {
		return location.pathname.replace("/r/", "");
	}

	constructor() {
		this.id = Room.id;

		Service.registerService(YouTube);
		Service.registerService(Twitch$1);
		Service.registerService(IFrames);

		this.player = new Player();
		document.querySelector(".player-container").appendChild(this.player);

		this.player.registerPlayerInterface(new YouTubePlayer('ytplayer'));
		this.player.registerPlayerInterface(new TwitchPlayer('twitchplayer'));
		this.player.registerPlayerInterface(new IFramePlayer('iframe'));

		this.socket = new WatchClient();

		this.player.addEventListener("ready", () => {
			this.init();
		});

		this.initPlayer();
	}

	initPlayer() {
		this.player.setupPlayer();

		const socket = this.socket;
		const player = this.player;

		let lastState = 0;

		// player events
		this.player.addEventListener("statechange", (e) => {
			lastState = e.detail.state;
		});

		function debounce(callback) {
			callback();
		}

		this.player.addEventListener("seek", (e) => {
			debounce(() => socket.emit('seek.video', { time: e.detail.time }));
		});

		this.player.addEventListener("play", () => {
			debounce(() => socket.emit('play.video'));
		});

		this.player.addEventListener("pause", () => {
			debounce(() => {
				if (lastState !== PlayerInterface.SEEKING) {
					socket.emit('pause.video');
					socket.emit('seek.video', { time: player.getCurrentTime() });
				}
			});
		});
	}

	addVideo(link) {
		const parsed = Service.parseServiceUrl(link);
		if (parsed) {
			this.socket.addVideoToQueue(parsed.service, parsed.id);
		} else {
			const noti = new Notification({ text: "Inavlid URL", time: 2000 });
			noti.display(document.querySelector("w2-notifications"));
		}
	}

	init() {
		const socket = this.socket;

		socket.init();

		document.querySelector(".sidebar w2-videolist#queue").removeVideo = (index, vid) => {
			socket.removeVideoFromQueue({ index, id: vid.id });
		};

		document.querySelector(".sidebar w2-videolist").playVideo = (index, vid) => {
			socket.loadVideo({ index, id: vid.id });
		};

		document.querySelector(".history w2-videolist").playVideo = (index, vid) => {
			const q = socket.addVideoToQueue(vid.service, vid.id);
			socket.loadVideo({ index: q.length, id: vid.id });
		};

		socket.connect(this.id);

		Preferences.subscribe((key, value) => {
			this.setRoomState({ hostonly: Preferences.get('hostonly') });
		});
	}

	setRoomState(obj) {
		this.socket.emit('room.state', obj);
	}

}window.addEventListener("DOMContentLoaded", onDomReady);
window.addEventListener("load", onLoad);

let room;

function onLoad() {
	room = new Room();
}

function onDomReady() {
	// UI stuff
	function bindButton(attr) {
		const state = document.body.getAttribute(attr) == "true" ? false : true;
		document.body.setAttribute(attr, state);
	}

	// Video Queue toggle button
	document.querySelector(".toggle-sidebar").onclick = () => bindButton("sidebar-open");
	document.querySelector(".toggle-history").onclick = () => bindButton("video-history-open");

	// video add button
	document.querySelector(".sidebar .add-video").addEventListener("click", e => {
		if (navigator.clipboard.readText) {
			navigator.clipboard.readText().then(clipText => {
				room.addVideo(clipText);
			});
		} else {
			new Notification({
				type: Notification.TEXT,
				text: "Use Ctrl+V for adding Videos.",
				time: 5000
			}).display(document.querySelector("w2-notifications"));

			new Notification({
				type: Notification.TEXT,
				text: "This browser does not support reading the Clipboard. \nUse Chrome for the best experience!",
				time: 6500
			}).display(document.querySelector("w2-notifications"));
		}
	});

	// support for stupid bvrowsers
	window.addEventListener('paste', e => {
		const pasteData = e.clipboardData.getData('text');
		room.addVideo(pasteData);
	});
}